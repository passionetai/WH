const GEMINI_CONFIG={API_URL:"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",API_KEY:"AIzaSyAd27ptuNgUsenf_vw2eQodBmm9kE-D8cE",IMAGE_API_URL:"https://generativelanguage.googleapis.com/v1/models/gemini-pro-vision:generateContent",IMAGE_API_KEY:"AIzaSyAd27ptuNgUsenf_vw2eQodBmm9kE-D8cE"};function scrollToHustleOutput(){const e=document.getElementById("hustle-output");setTimeout((()=>{e.scrollIntoView({behavior:"smooth",block:"start"})}),100)}async function fetchHustleData(city) {
    // Prevent multiple concurrent searches
    if (window.searchInProgress) {
        console.log("Search already in progress, ignoring new request");
        return;
    }
    
    window.searchInProgress = true;
    
    try {
        // Show initial loading state
        document.getElementById("hustle-output").innerHTML = `
            <div class="hustle-cards-container"></div>
            <div class="loading">
                <div class="loader-circle"></div>
                <span>Scanning hustle opportunities in <span id="loading-city">${city}</span>...</span>
                <div class="progress-bar">
                    <div class="progress-fill"></div>
                </div>
                <div style="font-size: 0.8em; margin-top: 10px; color: #666;">
                    We are scanning for the best hustles and this takes up to 30 seconds. Please be patient.
                </div>
            </div>
        `;
        
        // Display the output element
        document.getElementById("hustle-output").style.display = "block";
        scrollToHustleOutput();
        
        // Initialize progress animation
        startProgressAnimation();
        
        try {
            // Generate hustle data with the Gemini API
            const hustles = await generateHustleData(city);
            
            if (hustles && hustles.length > 0) {
                displayHustleCards(hustles, city);
            } else {
                showNoResults();
            }
        } catch (error) {
            console.error("Error generating hustle data:", error);
            showErrorState();
        }
    } catch (error) {
        console.error("Error in fetchHustleData:", error);
        showErrorState();
    } finally {
        window.searchInProgress = false;
    }
}

// Display hustle cards
function displayHustleCards(hustles, city) {
    // Get the hustle cards container
    const hustleCardsContainer = document.querySelector(".hustle-cards-container");
    
    // Clear loading element
    const loadingElement = document.querySelector(".loading");
    if (loadingElement) loadingElement.remove();
    
    // Update hustle cards container
    hustleCardsContainer.innerHTML = "";
    
    // Create heading
    const heading = document.createElement("h2");
    heading.classList.add("hustles-heading");
    heading.setAttribute("tabindex", "0");
    heading.textContent = `${hustles.length} Side Hustles in ${city}`;
    hustleCardsContainer.appendChild(heading);
    
    // Create cards grid container
    const cardsGrid = document.createElement("div");
    cardsGrid.classList.add("cards-grid");
    hustleCardsContainer.appendChild(cardsGrid);
    
    // Add each hustle card
    hustles.forEach((hustle) => {
        const card = createHustleCard(hustle, city);
        cardsGrid.appendChild(card);
    });
}

function renderHustles(hustles, city, isGeminiResponse, outputElement) {
    // Clear progress interval if it exists
    if (window.progressInterval) {
        clearInterval(window.progressInterval);
        window.progressInterval = null;
    }
    
    // Get the existing city image container
    const hustleCardsContainer = document.querySelector(".hustle-cards-container");
    
    // Clear the main container but keep the city image container
    const loadingElement = outputElement.querySelector(".loading");
    if (loadingElement) {
        loadingElement.remove();
    }
    
    // Create or get the hustle cards container
    if (!hustleCardsContainer) {
        const newHustleCardsContainer = document.createElement("div");
        newHustleCardsContainer.classList.add("hustle-cards-container");
        outputElement.appendChild(newHustleCardsContainer);
    }
    
    // Get the hustle cards container (whether it existed or was just created)
    const cardsContainer = outputElement.querySelector(".hustle-cards-container");
    
    // Clear the current content of the cards container
    cardsContainer.innerHTML = "";
    
    // Create heading
    const heading = document.createElement("h2");
    heading.classList.add("hustles-heading");
    heading.setAttribute("tabindex", "0");
    heading.textContent = `${hustles.length} Side Hustles in ${city}`;
    cardsContainer.appendChild(heading);
    
    // Create cards grid
    const cardsGrid = document.createElement("div");
    cardsGrid.classList.add("cards-grid");
    cardsContainer.appendChild(cardsGrid);
    
    // Add each hustle card
    hustles.forEach(hustle => {
        const card = createHustleCard(hustle, city, isGeminiResponse);
        cardsGrid.appendChild(card);
    });
}

// Show error message function
function showError(message) {
    // Clear progress interval if it exists
    if (window.progressInterval) {
        clearInterval(window.progressInterval);
        window.progressInterval = null;
    }
    
    const hustleOutput = document.getElementById("hustle-output");
    hustleOutput.style.display = "block";
    hustleOutput.innerHTML = `<div class="error">${message}</div>`;
    scrollToHustleOutput();
}

function parseHustles(e,t){const n=[],i=e.split(/Name:/g).filter((e=>e.trim()));for(const e of i.slice(0,3)){const t="Name:"+e,i={name:"",summary:"",difficulty:"",profitability:"",cost:"",metrics:{startupTime:"",breakEven:"",scalability:""},actionPlan:[],resources:{tools:[],platforms:[],communities:[]},monetization:[],risks:[]},s=t.match(/Name:\s*(.+?)(?=\n|Executive)/);s&&(i.name=s[1].trim());const o=t.match(/Executive Summary:\s*(.+?)(?=\n|Difficulty)/s);o&&(i.summary=o[1].trim());const a=t.match(/Difficulty:\s*(.+?)(?=\n|Profitability)/);a&&(i.difficulty=a[1].trim());const r=t.match(/Profitability:\s*(.+?)(?=\n|Cost)/);r&&(i.profitability=r[1].trim());const l=t.match(/Cost:\s*(.+?)(?=\n|Key Metrics)/);l&&(i.cost=l[1].trim());const c=t.match(/Key Metrics:\s*(.+?)(?=\n\nAction Plan)/s);if(c){const e=c[1],t=e.match(/Startup Time:\s*(.+?)(?=\n|-)/);t&&(i.metrics.startupTime=t[1].trim());const n=e.match(/Break-even Point:\s*(.+?)(?=\n|-)/);n&&(i.metrics.breakEven=n[1].trim());const s=e.match(/Scalability:\s*(.+?)(?=\n|$)/);s&&(i.metrics.scalability=s[1].trim())}const m=t.match(/Action Plan \(First Month\):\s*(.+?)(?=\n\nResources)/s);if(m){const e=m[1].match(/Week \d+:.*?(?=\n|$)/g);e&&(i.actionPlan=e.map((e=>e.trim())))}const u=t.match(/Resources:\s*(.+?)(?=\n\nMonetization)/s);if(u){const e=u[1],t=e.match(/Tools:\s*(.+?)(?=\n|Platforms)/);t&&(i.resources.tools=t[1].split(",").map((e=>e.trim())).filter((e=>e)));const n=e.match(/Platforms:\s*(.+?)(?=\n|Communities)/);n&&(i.resources.platforms=n[1].split(",").map((e=>e.trim())).filter((e=>e)));const s=e.match(/Communities:\s*(.+?)(?=\n|$)/);s&&(i.resources.communities=s[1].split(",").map((e=>e.trim())).filter((e=>e)))}const d=t.match(/Monetization:\s*(.+?)(?=\n\nRisk Analysis)/s);if(d){const e=d[1].match(/\d+\.\s*.*?(?=\n|$)/g);e&&(i.monetization=e.map((e=>e.replace(/^\d+\.\s*/,"").trim())))}const p=t.match(/Risk Analysis:\s*(.+?)(?=$)/s);if(p){const e=p[1],t=e.match(/Challenge:\s*.*?(?=\n|$)/g),n=e.match(/Solution:\s*.*?(?=\n|-|$)/g);if(t&&n)for(let e=0;e<Math.min(t.length,n.length);e++)i.risks.push({challenge:t[e].replace("Challenge:","").trim(),solution:n[e].replace("Solution:","").trim()})}i.name&&i.summary&&n.push(i)}return n.length>0?n:null}document.addEventListener("DOMContentLoaded",(function(){
    // Clear and hide the hustle output on initial load
    const hustleOutput = document.getElementById("hustle-output");
    hustleOutput.innerHTML = "";
    hustleOutput.style.display = "none";
    
    const e=document.getElementById("city-input"),t=document.getElementById("get-hustle-btn"),n=document.querySelectorAll(".city-btn");t.addEventListener("click",(function(){const t=e.value.trim();t?(hustleOutput.style.display = "block", fetchHustleData(t)):(showError("Please enter a city name"),scrollToHustleOutput())})),n.forEach((t=>{t.addEventListener("click",(async function(){const t=this.textContent;n.forEach((e=>{e.disabled=!0,e.style.cursor="not-allowed"})),this.textContent="Loading...",this.classList.add("loading"),n.forEach((e=>e.classList.remove("active"))),this.classList.add("active");const i=this.getAttribute("data-city");e.value=i;try{hustleOutput.style.display = "block", await fetchHustleData(i),document.getElementById("hustle-output").scrollIntoView({behavior:"smooth"})}finally{this.textContent=t,this.classList.remove("loading"),n.forEach((e=>{e.disabled=!1,e.style.cursor="pointer"}))}}))})),e.addEventListener("keypress",(async function(t){if("Enter"===t.key){const t=e.value.trim();if(t){hustleOutput.style.display = "block"; const e=document.querySelector(`.city-btn[data-city="${t}"]`);if(e){const n=e.textContent;e.textContent="Loading...",e.classList.add("loading"),document.querySelectorAll(".city-btn").forEach((e=>{e.disabled=!0,e.style.cursor="not-allowed"}));try{await fetchHustleData(t),document.querySelectorAll(".city-btn").forEach((e=>e.classList.remove("active"))),e.classList.add("active")}finally{e.textContent=n,e.classList.remove("loading"),document.querySelectorAll(".city-btn").forEach((e=>{e.disabled=!1,e.style.cursor="pointer"}))}}else await fetchHustleData(t)}else showError("Please enter a city name"),scrollToHustleOutput()}}))}));let previousHustleNames=[];async function fetchHustleFromGemini(e,t=0){
    try{
        const n=`Generate 3 highly unique and unconventional side hustles tailored to ${e}'s local economy, culture, demographics, and untapped opportunities. Avoid common ideas like food delivery, tutoring, or generic freelancing. ${previousHustleNames.length>0?`Do not repeat these previous ideas: ${previousHustleNames.join(", ")}.`:""} Format EXACTLY like:\n\nName: [Business Name]\nExecutive Summary: [2-3 sentences describing the opportunity]\nDifficulty: [Easy/Medium/Hard]\nProfitability: [$/month range with specific numbers]\nCost: [Initial cost breakdown with specific numbers]\n\nKey Metrics:\n- Startup Time: [X weeks based on complexity, must be specific]\n- Break-even Point: [Y months with calculation based on costs and revenue]\n- Scalability: [Low/Medium/High with detailed explanation]\n\nAction Plan (First Month):\nWeek 1: [specific actionable milestone with measurable outcome]\nWeek 2: [specific actionable milestone with measurable outcome]\nWeek 3: [specific actionable milestone with measurable outcome]\nWeek 4: [specific actionable milestone with measurable outcome]\n\nResources:\n- Tools: [List exactly 3-5 specific tools with actual names and brief purpose]\n- Platforms: [List exactly 2-3 specific platforms with actual names]\n- Communities: [1 specific local community in ${e} + 1 specific online community]\n\nMonetization:\n1. [Primary revenue stream with exact pricing and volume estimates]\n2. [Secondary revenue stream with exact pricing and volume estimates]\n3. [Additional revenue stream with exact pricing and volume estimates]\n\nRisk Analysis:\n- Challenge: [specific realistic risk with quantifiable impact]\n  Solution: [detailed actionable mitigation steps]\n- Challenge: [specific realistic risk with quantifiable impact]\n  Solution: [detailed actionable mitigation steps]\n\nCRITICAL INSTRUCTION: You MUST provide complete, specific, and realistic details for EVERY section of ALL 3 hustles. Omitting or providing vague details for any section will force a retry. Each hustle must be distinct, creative, and rooted in ${e}'s unique characteristics (e.g., local industries, climate, population trends, or subcultures). Every metric must include specific numbers, every action must be measurable, and every solution must be actionable. Responses with placeholders, generic answers, or incomplete sections will be rejected.`,i=await fetch(`${GEMINI_CONFIG.API_URL}?key=${GEMINI_CONFIG.API_KEY}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({contents:[{parts:[{text:n}]}],safetySettings:[{category:"HARM_CATEGORY_DANGEROUS_CONTENT",threshold:"BLOCK_ONLY_HIGH"}],generationConfig:{maxOutputTokens:1500,temperature:1.2,topP:.9,topK:50}})});if(!i.ok)throw new Error(`API Error: ${i.status}`);const s=await i.json(),o=parseHustles(s?.candidates?.[0]?.content?.parts?.[0]?.text||"",e);if(!o)throw new Error("Invalid hustle data format");const a=o.map((e=>validateHustleQuality(e))),r=a.some((e=>e.completeness<.9)),l=a.reduce(((e,t)=>e+t.completeness),0)/a.length;return(r||l<.85)&&t<4?(console.log(`Incomplete or low-quality response (Avg: ${Math.round(100*l)}%). Retrying...`),fetchHustleFromGemini(e,t+1)):(previousHustleNames=[...new Set([...previousHustleNames,...a.map((e=>e.hustle.name))])].slice(-10),a.map((e=>e.hustle)))}catch(e){throw console.error("API Error:",e),new Error("Failed to connect to hustle database")}}function validateHustleQuality(e){const t={name:.05,summary:.1,difficulty:.05,profitability:.05,cost:.05,metrics:{startupTime:.05,breakEven:.05,scalability:.05},actionPlan:.15,resources:{tools:.05,platforms:.05,communities:.05},monetization:.2,risks:.2};let n=0;for(const[i,s]of Object.entries(t))if("object"==typeof s)for(const[t,o]of Object.entries(s))e[i][t]&&("string"==typeof e[i][t]?e[i][t].length>0:!Array.isArray(e[i][t])||e[i][t].length>0)&&(n+=o);else e[i]&&("string"==typeof e[i]?e[i].length>0:!Array.isArray(e[i])||e[i].length>0)&&(n+=s);return Array.isArray(e.actionPlan)&&e.actionPlan.length>=4&&(n+=.025),Array.isArray(e.monetization)&&e.monetization.length>=3&&(n+=.05),Array.isArray(e.risks)&&e.risks.length>=2&&(n+=.05),Array.isArray(e.resources.tools)&&e.resources.tools.length>=3&&(n+=.025),Array.isArray(e.resources.platforms)&&e.resources.platforms.length>=2&&(n+=.025),Array.isArray(e.resources.communities)&&e.resources.communities.length>=2&&(n+=.025),{hustle:e,completeness:n,isHighQuality:n>=.9}}function getFallbackHustles(e){return[{name:`${e} Local Experiences Tour Guide`,summary:`Offer unique, themed walking tours focused on specific areas or interests in ${e}, appealing to tourists and locals. Leverage local knowledge and create memorable experiences beyond typical tourist traps.`,difficulty:"Medium",profitability:"$500 - $2000/month",cost:"$150 (Website domain, initial marketing materials)",metrics:{startupTime:"4-6 weeks",breakEven:"2-3 months",scalability:"Medium - Can expand to multiple tour themes and hire additional guides"},actionPlan:['Week 1: Define tour themes (e.g., "Hidden Gems of Downtown", "Literary History Tour", "Local Cuisine Experience"). Research routes and points of interest.',"Week 2: Create website or landing page with tour descriptions, schedules, and booking information.","Week 3: Market tours online through social media and local listings. Offer introductory discounts.","Week 4: Conduct initial tours, gather feedback, and refine the tour experience."],resources:{tools:["Booking software","Portable microphone/speaker","Digital camera"],platforms:["TripAdvisor","Airbnb Experiences"],communities:[`${e} Tourism Board`,"Facebook Group: Tour Guides Worldwide"]},monetization:["Standard tours: $25-40 per person for 2-hour experiences","Premium/private tours: $150-200 for groups up to 6 people","Custom corporate team-building tours: $400-600 per event"],risks:[{challenge:"Seasonal tourism fluctuations",solution:"Develop special off-season tours targeting locals and business travelers"},{challenge:"Competition from established tour companies",solution:"Focus on unique niches and specialized knowledge that larger companies don't cover"}]},{name:`${e} Mobile Pet Grooming Service`,summary:`Provide convenient, stress-free pet grooming services directly at customers' homes in ${e}. Cater to busy pet owners who value convenience and pets that experience anxiety in traditional grooming environments.`,difficulty:"Medium",profitability:"$1,500 - $4,000/month",cost:"$2,000 - $5,000 (Equipment, supplies, vehicle modifications)",metrics:{startupTime:"6-8 weeks",breakEven:"4-6 months",scalability:"High - Can add additional mobile units and groomers"},actionPlan:["Week 1: Research local pet demographics and competitors. Obtain necessary licenses and insurance.","Week 2: Purchase equipment and supplies. Set up booking and payment system.","Week 3: Create website and social media presence. Begin targeted marketing to pet owners.","Week 4: Offer promotional pricing for initial customers to build reviews and referrals."],resources:{tools:["Mobile grooming equipment","Scheduling software","Pet-friendly cleaning supplies"],platforms:["Instagram","NextDoor"],communities:[`${e} Pet Owners Association`,"Online Pet Groomers Network"]},monetization:["Basic grooming package: $65-85 per small dog, $85-120 per large dog","Premium spa packages: $100-150 including specialized treatments","Membership subscriptions: $50/month discount for recurring monthly appointments"],risks:[{challenge:"Vehicle and equipment maintenance issues",solution:"Establish relationships with reliable mechanics and keep backup equipment"},{challenge:"Handling difficult or aggressive pets",solution:"Obtain specialized training in animal behavior and implement clear policies for pet evaluation"}]},{name:`${e} Local Food Delivery Collective`,summary:`Create a cooperative delivery service exclusively for local, independent restaurants in ${e} that can't afford high fees from mainstream delivery apps. Provide fair pricing for restaurants and better compensation for drivers.`,difficulty:"Hard",profitability:"$2,000 - $6,000/month",cost:"$3,000 - $8,000 (App development, marketing, legal setup)",metrics:{startupTime:"10-12 weeks",breakEven:"8-10 months",scalability:"Medium - Limited to local market but can expand to neighboring areas"},actionPlan:["Week 1: Survey local restaurants about pain points with current delivery services. Begin legal formation of cooperative structure.","Week 2: Develop initial version of ordering platform or app. Begin recruiting delivery drivers.","Week 3: Onboard first 5-10 restaurant partners and conduct platform testing.","Week 4: Soft launch with limited service area and hours. Gather feedback for improvements."],resources:{tools:["Order management software","Route optimization tools","Payment processing system"],platforms:["Custom mobile app","Instagram"],communities:[`${e} Restaurant Association`,"Independent Restaurant Alliance"]},monetization:["Restaurant commission: 10-15% of order value (versus 25-35% from major apps)","Customer delivery fee: $3.99-5.99 based on distance","Premium membership option: $9.99/month for free delivery and priority service"],risks:[{challenge:"Competition from well-funded delivery apps",solution:"Emphasize local ownership, better restaurant economics, and community support in marketing"},{challenge:"Technology reliability issues",solution:"Implement backup systems and clear manual processes for when technical issues arise"}]}]}const scrollTopBtn=document.querySelector(".scroll-top-btn");function scrollToHustleOutput(){const e=document.getElementById("hustle-output");e&&e.scrollIntoView({behavior:"smooth",block:"start"})}async function reloadSectionFromGemini(e,t,n){const i={"action-plan":`Generate a detailed Action Plan (First Month) for the side hustle "${t}" in ${e}. Format EXACTLY like:\n    Action Plan (First Month):\n    Week 1: [specific milestone]\n    Week 2: [specific milestone]\n    Week 3: [specific milestone]\n    Week 4: [specific milestone]\n    Provide 4 specific, realistic milestones tailored to ${e}.`,monetization:`Generate a detailed Monetization plan for the side hustle "${t}" in ${e}. Format EXACTLY like:\n    Monetization:\n    1. [Primary revenue stream with detailed pricing]\n    2. [Secondary revenue stream with detailed pricing]\n    3. [Additional revenue stream with detailed pricing]\n    Provide 3 specific, realistic revenue streams tailored to ${e}.`,"risk-analysis":`Generate a detailed Risk Analysis for the side hustle "${t}" in ${e}. Format EXACTLY like:\n    Risk Analysis:\n    - Challenge: [specific realistic risk 1]\n      Solution: [specific actionable mitigation 1]\n    - Challenge: [specific realistic risk 2]\n      Solution: [specific actionable mitigation 2]\n    Provide 2 specific, realistic risks and solutions tailored to ${e}.`}[n];if(!i)throw new Error("Invalid section");const s=await fetch(`${GEMINI_CONFIG.API_URL}?key=${GEMINI_CONFIG.API_KEY}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({contents:[{parts:[{text:i}]}],safetySettings:[{category:"HARM_CATEGORY_DANGEROUS_CONTENT",threshold:"BLOCK_ONLY_HIGH"}],generationConfig:{maxOutputTokens:500,temperature:1.2,topP:.9,topK:50}})});if(!s.ok)throw new Error(`API Error: ${s.status}`);const o=await s.json(),a=o?.candidates?.[0]?.content?.parts?.[0]?.text||"";switch(n){case"action-plan":return(a.match(/Week \d+:.*?(?=\n|$)/g)||[]).map((e=>e.trim()));case"monetization":return(a.match(/\d+\.\s*.*?(?=\n|$)/g)||[]).map((e=>e.replace(/^\d+\.\s*/,"").trim()));case"risk-analysis":const e=a.match(/Challenge:\s*.*?(?=\n|$)/g)||[],t=a.match(/Solution:\s*.*?(?=\n|-|$)/g)||[];return e.map(((e,n)=>({challenge:e.replace("Challenge:","").trim(),solution:t[n]?.replace("Solution:","").trim()||"N/A"})));default:return null}}function updateHustleSection(e,t,n,i){if(e[t])switch(n){case"action-plan":Array.isArray(i)&&i.length>=4&&(e[t].actionPlan=i);break;case"monetization":Array.isArray(i)&&i.length>=3&&(e[t].monetization=i);break;case"risk-analysis":Array.isArray(i)&&i.length>=2&&(e[t].risks=i)}}window.addEventListener("scroll",(()=>{window.pageYOffset>100?scrollTopBtn.style.display="block":scrollTopBtn.style.display="none"})),scrollTopBtn.addEventListener("click",(()=>{window.scrollTo({top:0,behavior:"smooth"})})),document.getElementById("get-hustle-btn").addEventListener("click",(()=>{scrollToHustleOutput()})),document.getElementById("city-input").addEventListener("keypress",(e=>{"Enter"===e.key&&(e.preventDefault(),document.getElementById("get-hustle-btn").click(),scrollToHustleOutput())})),document.querySelectorAll(".city-btn").forEach((e=>{e.addEventListener("click",(()=>{scrollToHustleOutput()}))}));const CITY_CURRENCY_MAP={
    nairobi:{code:"KES",symbol:"KSh"},
    lagos:{code:"NGN",symbol:"₦"},
    johannesburg:{code:"ZAR",symbol:"R"},
    london:{code:"GBP",symbol:"£"},
    "new york":{code:"USD",symbol:"$"},
    tokyo:{code:"JPY",symbol:"¥"},
    mumbai:{code:"INR",symbol:"₹"},
    dubai:{code:"AED",symbol:"د.إ"},
    singapore:{code:"SGD",symbol:"S$"},
    sydney:{code:"AUD",symbol:"A$"},
    rome:{code:"EUR",symbol:"€"},
    madrid:{code:"EUR",symbol:"€"},
    vienna:{code:"EUR",symbol:"€"},
    bangkok:{code:"THB",symbol:"฿"},
    shanghai:{code:"CNY",symbol:"¥"},
    istanbul:{code:"TRY",symbol:"₺"}
},
FALLBACK_CURRENCY={code:"USD",symbol:"$"};function getLocalCurrency(e){const t=e.trim().toLowerCase(),n=CITY_CURRENCY_MAP[t]||FALLBACK_CURRENCY;return n.format=e=>{const t=e.toString().replace(/[^0-9.-]+/g,"");return`${n.symbol}${t}`},n}function formatHustleForCopy(e){let t=`HUSTLE IDEA: ${e.name}\n\n`;return t+=`EXECUTIVE SUMMARY:\n${e.summary}\n\n`,t+=`DIFFICULTY: ${e.difficulty}\n`,t+=`PROFITABILITY: ${e.profitability}\n`,t+=`INITIAL COST: ${e.cost}\n\n`,t+="KEY METRICS:\n",t+=`- Startup Time: ${e.metrics.startupTime}\n`,t+=`- Break-even: ${e.metrics.breakEven}\n`,t+=`- Scalability: ${e.metrics.scalability}\n\n`,t+="ACTION PLAN (FIRST MONTH):\n",e.actionPlan.forEach(((e,n)=>{t+=`- ${e}\n`})),t+="\n",t+="RESOURCES:\n",t+=`- Tools: ${e.resources.tools.join(", ")}\n`,t+=`- Platforms: ${e.resources.platforms.join(", ")}\n`,t+=`- Communities: ${e.resources.communities.join(", ")}\n\n`,t+="MONETIZATION STREAMS:\n",e.monetization.forEach(((e,n)=>{t+=`${n+1}. ${e}\n`})),t+="\n",t+="RISK ANALYSIS:\n",e.risks.forEach((e=>{t+=`- Challenge: ${e.challenge}\n`,t+=`  Solution: ${e.solution}\n`})),t}

// Function to set up button event listeners
function setupButtonEventListeners(hustlesArray) {
    // Copy hustle buttons
    document.querySelectorAll('.copy-hustle-btn').forEach(button => {
        button.addEventListener('click', function() {
            const index = parseInt(this.getAttribute('data-hustle-index'));
            const hustle = hustlesArray[index];
            
            if (hustle) {
                const hustleText = formatHustleForCopy(hustle);
                
                // Copy to clipboard
                navigator.clipboard.writeText(hustleText).then(
                    function() {
                        // Success
                        button.classList.add('copied');
                        button.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                            Copied!
                        `;
                        
                        setTimeout(() => {
                            button.classList.remove('copied');
                            button.innerHTML = `
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                </svg>
                                Copy
                            `;
                        }, 2000);
                    },
                    function(err) {
                        console.error('Could not copy text: ', err);
                    }
                );
            }
        });
    });
    
    // Save hustle buttons
    document.querySelectorAll('.save-hustle-btn').forEach(button => {
        button.addEventListener('click', function() {
            const index = parseInt(this.getAttribute('data-hustle-index'));
            const hustle = hustlesArray[index];
            
            if (hustle) {
                // Get existing saved hustles from localStorage
                let savedHustles = JSON.parse(localStorage.getItem('savedHustles') || '[]');
                
                // Check if hustle is already saved (by name)
                const isAlreadySaved = savedHustles.some(saved => saved.name === hustle.name);
                
                if (!isAlreadySaved) {
                    // Add to saved hustles
                    savedHustles.push(hustle);
                    localStorage.setItem('savedHustles', JSON.stringify(savedHustles));
                    
                    // Update button appearance
                    button.classList.add('saved');
                    button.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
                        </svg>
                        Saved
                    `;
                } else {
                    // Already saved, show message
                    button.classList.add('saved');
                    button.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
                        </svg>
                        Saved
                    `;
                    
                    setTimeout(() => {
                        button.classList.remove('saved');
                        button.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
                            </svg>
                            Save
                        `;
                    }, 2000);
                }
            }
        });
    });
    
    // Share hustle buttons
    document.querySelectorAll('.share-hustle-btn').forEach(button => {
        button.addEventListener('click', function() {
            const index = parseInt(this.getAttribute('data-hustle-index'));
            const hustle = hustlesArray[index];
            
            if (hustle) {
                // Create shareable content
                const title = `Check out this hustle idea: ${hustle.name}`;
                const text = `${hustle.summary}\n\nProfitability: ${hustle.profitability}\nDifficulty: ${hustle.difficulty}`;
                const hustleTitle = hustle.name.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
                const shareUrl = `https://wehustle.it.com/?hustle=${encodeURIComponent(hustleTitle)}`;
                
                // Use Web Share API if available
                if (navigator.share) {
                    navigator.share({
                        title: title,
                        text: text,
                        url: shareUrl
                    })
                    .then(() => {
                        console.log('Shared successfully');
                    })
                    .catch(err => {
                        console.error('Share failed:', err);
                        // Fall back to clipboard if share fails
                        fallbackToClipboard();
                    });
                } else {
                    // Fallback for browsers without Web Share API
                    fallbackToClipboard();
                }
                
                // Fallback function to copy to clipboard
                function fallbackToClipboard() {
                    const shareText = `${title}\n\n${text}\n\n${shareUrl}`;
                    navigator.clipboard.writeText(shareText)
                        .then(() => {
                            alert("Link copied to clipboard!");
                            
                            // Success feedback on button
                            button.textContent = 'Link Copied!';
                            setTimeout(() => {
                                button.textContent = 'Share This Hustle';
                            }, 2000);
                        })
                        .catch(err => {
                            console.error('Could not copy link: ', err);
                            alert('Error copying link to clipboard');
                        });
                }
            }
        });
    });
    
    // Set up regenerate button event listeners if they exist
    document.querySelectorAll(".regenerate-btn").forEach(btn => {
        btn.addEventListener("click", async function() {
            const index = parseInt(this.getAttribute("data-hustle-index"));
            const sectionType = this.getAttribute("data-type");
            const hustle = hustlesArray[index];
            const cityName = document.querySelector(".city-btn.active")?.textContent || 
                document.getElementById("city-input").value.trim();
            
            if (hustle && cityName) {
                const button = this;
                const originalText = button.innerHTML;
                button.disabled = true;
                button.innerHTML = `<span class="spinning-emoji">🔄</span> Regenerating...`;
                
                try {
                    const newData = await reloadSectionFromGemini(cityName, hustle.name, sectionType);
                    updateHustleSection(hustlesArray, index, sectionType, newData);
                    
                    // Re-render the hustle cards
                    const filterValue = document.getElementById("difficulty-filter").value;
                    const filteredHustles = filterValue === "all" ? 
                        hustlesArray : 
                        hustlesArray.filter(h => h.difficulty.toLowerCase() === filterValue);
                    
                    const cardsContainer = document.querySelector(".hustle-cards-container");
                    renderFilteredHustles(filteredHustles, cardsContainer, hustlesArray);
                    setupButtonEventListeners(hustlesArray);
                    
                } catch (error) {
                    console.error("Failed to regenerate section:", error);
                    alert("Failed to regenerate section. Please try again.");
                } finally {
                    button.disabled = false;
                    button.innerHTML = originalText;
                }
            }
        });
    });
}

// Function to initialize particles.js with subtle configuration
function initParticles() {
    if (typeof particlesJS !== 'undefined') {
        particlesJS('particles-js', {
            "particles": {
                "number": {
                    "value": 100,
                    "density": {
                        "enable": true,
                        "value_area": 1000
                    }
                },
                "color": {
                    "value": "#007AFF"
                },
                "shape": {
                    "type": "circle",
                    "stroke": {
                        "width": 0,
                        "color": "#000000"
                    }
                },
                "opacity": {
                    "value": 0.5,
                    "random": false,
                    "anim": {
                        "enable": false,
                        "speed": 0.5,
                        "opacity_min": 0.1,
                        "sync": false
                    }
                },
                "size": {
                    "value": 2,
                    "random": true,
                    "anim": {
                        "enable": false,
                        "speed": 20,
                        "size_min": 0.1,
                        "sync": false
                    }
                },
                "line_linked": {
                    "enable": true,
                    "distance": 150,
                    "color": "#34C759",
                    "opacity": 0.3,
                    "width": 0.5
                },
                "move": {
                    "enable": true,
                    "speed": 1,
                    "direction": "none",
                    "random": false,
                    "straight": false,
                    "out_mode": "out",
                    "bounce": false,
                    "attract": {
                        "enable": false,
                        "rotateX": 600,
                        "rotateY": 1200
                    }
                }
            },
            "interactivity": {
                "detect_on": "canvas",
                "events": {
                    "onhover": {
                        "enable": true,
                        "mode": "grab"
                    },
                    "onclick": {
                        "enable": true,
                        "mode": "push"
                    },
                    "resize": true
                },
                "modes": {
                    "grab": {
                        "distance": 140,
                        "line_linked": {
                            "opacity": 1
                        }
                    },
                    "push": {
                        "particles_nb": 3
                    }
                }
            },
            "retina_detect": true
        });
    }
}

// Wait for DOM to be fully loaded
document.addEventListener("DOMContentLoaded", function() {
    // Initialize particles
    initParticles();
    
    // Clear and hide the hustle output on initial load
    const hustleOutput = document.getElementById("hustle-output");
    if (hustleOutput) {
        hustleOutput.innerHTML = "";
        hustleOutput.style.display = "none";
    }
    
    // Setup event listeners for main page
    setupMainPageListeners();
    
    // Check if we're on the saved hustles page
    const savedHustlesOutput = document.getElementById("saved-hustles-output");
    if (savedHustlesOutput) {
        loadSavedHustles();
    }
});

function setupMainPageListeners() {
    const cityInput = document.getElementById("city-input");
    const getHustleBtn = document.getElementById("get-hustle-btn");
    const cityBtns = document.querySelectorAll(".city-btn");
    
    if (!cityInput || !getHustleBtn) return; // Not on the main page
    
    // Prevent any form submission
    const searchForm = cityInput.closest('form');
    if (searchForm) {
        searchForm.addEventListener('submit', function(e) {
            e.preventDefault();
            return false;
        });
    }
    
    // Debounce the search button click
    let lastClickTime = 0;
    getHustleBtn.addEventListener("click", function(e) {
        e.preventDefault(); // Prevent any default actions
        
        // Debounce: ignore clicks that happen too quickly
        const now = Date.now();
        if (now - lastClickTime < 500) { // 500ms debounce time
            return;
        }
        lastClickTime = now;
        
        const cityName = cityInput.value.trim();
        if (cityName) {
            document.getElementById("hustle-output").style.display = "block";
            fetchHustleData(cityName);
        } else {
            showError("Please enter a city name");
            scrollToHustleOutput();
        }
    });
    
    cityBtns.forEach(btn => {
        btn.addEventListener("click", async function(e) {
            e.preventDefault(); // Prevent any default actions
            
            // If a search is already in progress, ignore
            if (window.searchInProgress) {
                return;
            }
            
            const originalText = this.textContent;
            cityBtns.forEach(b => {
                b.disabled = true;
                b.style.cursor = "not-allowed";
            });
            this.textContent = "Loading...";
            this.classList.add("loading");
            
            cityBtns.forEach(b => b.classList.remove("active"));
            this.classList.add("active");
            
            const cityName = this.getAttribute("data-city");
            cityInput.value = cityName;
            
            try {
                document.getElementById("hustle-output").style.display = "block";
                await fetchHustleData(cityName);
                document.getElementById("hustle-output").scrollIntoView({behavior: "smooth"});
            } finally {
                this.textContent = originalText;
                this.classList.remove("loading");
                cityBtns.forEach(b => {
                    b.disabled = false;
                    b.style.cursor = "pointer";
                });
            }
        });
    });
    
    cityInput.addEventListener("keypress", async function(e) {
        if (e.key === "Enter") {
            e.preventDefault();
            // Don't trigger if a search is already in progress
            if (!window.searchInProgress) {
                document.getElementById("get-hustle-btn").click();
                scrollToHustleOutput();
            }
        }
    });
}

// Function to load and display saved hustles
function loadSavedHustles() {
    const savedHustlesOutput = document.getElementById("saved-hustles-output");
    const savedHustles = localStorage.getItem("savedHustles") ? 
        JSON.parse(localStorage.getItem("savedHustles")) : [];
    
    if (savedHustles.length === 0) {
        savedHustlesOutput.innerHTML = `
            <div class="no-saved-hustles">
                <p>You haven't saved any hustles yet!</p>
                <a href="index.html" class="back-to-home">Find hustles to save</a>
            </div>
        `;
        return;
    }
    
    // Create container for the cards
    const cardsContainer = document.createElement("div");
    cardsContainer.className = "hustle-cards-container";
    savedHustlesOutput.appendChild(cardsContainer);
    
    // Create filter container
    const filterContainer = document.createElement("div");
    filterContainer.id = "filter-container";
    filterContainer.innerHTML = `
        <label for="difficulty-filter">Filter by Difficulty:</label>
        <select id="difficulty-filter">
            <option value="all">All Difficulties</option>
            <option value="easy">Easy</option>
            <option value="medium">Medium</option>
            <option value="hard">Hard</option>
        </select>
    `;
    savedHustlesOutput.insertBefore(filterContainer, cardsContainer);
    
    // Render the saved hustles
    renderFilteredHustles(savedHustles, cardsContainer, savedHustles);
    
    // Setup event listener for difficulty filter
    document.getElementById("difficulty-filter").addEventListener("change", function() {
        const selectedDifficulty = this.value;
        
        let filteredHustles = selectedDifficulty === "all" ? 
            savedHustles : 
            savedHustles.filter(hustle => hustle.difficulty.toLowerCase() === selectedDifficulty);
        
        renderFilteredHustles(filteredHustles, cardsContainer, savedHustles);
        setupSavedHustlesEventListeners(savedHustles);
    });
    
    // Setup event listeners for the cards
    setupSavedHustlesEventListeners(savedHustles);
}

// Function to set up event listeners for saved hustles
function setupSavedHustlesEventListeners(hustlesArray) {
    // Set up copy button event listeners
    document.querySelectorAll(".copy-hustle-btn").forEach(btn => {
        btn.addEventListener("click", function() {
            const index = parseInt(this.getAttribute("data-hustle-index"));
            const hustle = hustlesArray[index];
            if (hustle) {
                const copyText = formatHustleForCopy(hustle);
                navigator.clipboard.writeText(copyText).then(() => {
                    const originalHTML = this.innerHTML;
                    this.classList.add("copied");
                    this.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="20 6 9 17 4 12"></polyline>
                        </svg>
                        Copied!
                    `;
                    setTimeout(() => {
                        this.innerHTML = originalHTML;
                        this.classList.remove("copied");
                    }, 2000);
                }).catch(error => {
                    console.error("Failed to copy text: ", error);
                });
            }
        });
    });
    
    // Set up delete button event listeners
    document.querySelectorAll(".delete-hustle-btn").forEach(btn => {
        btn.addEventListener("click", function() {
            const index = parseInt(this.getAttribute("data-hustle-index"));
            const hustle = hustlesArray[index];
            
            if (hustle && confirm(`Are you sure you want to delete "${hustle.name}"?`)) {
                // Remove hustle from array
                const savedHustles = localStorage.getItem("savedHustles") ? 
                    JSON.parse(localStorage.getItem("savedHustles")) : [];
                
                const updatedHustles = savedHustles.filter(h => h.name !== hustle.name);
                localStorage.setItem("savedHustles", JSON.stringify(updatedHustles));
                
                // Reload the page to refresh the list
                window.location.reload();
            }
        });
    });
}

// Function to render hustles based on filter
function renderFilteredHustles(filteredHustles, container, allHustles) {
    // Clear container
    container.innerHTML = "";
    
    // If no hustles match the filter, show a message
    if (filteredHustles.length === 0) {
        container.innerHTML = `
            <div class="missing-section" style="width: 100%;">
                <p class="missing-text">No hustles found with the selected difficulty</p>
            </div>
        `;
        return;
    }
    
    // Determine if we're on the saved hustles page
    const isOnSavedPage = document.getElementById("saved-hustles-output") !== null;
    
    // Create cards for each filtered hustle
    filteredHustles.forEach(hustle => {
        // Normalize difficulty to lowercase
        const normalizedDifficulty = hustle.difficulty.toLowerCase();
        
        const card = document.createElement("div");
        card.className = "hustle-card";
        card.setAttribute("data-difficulty", normalizedDifficulty);
        
        // Generate different HTML for saved page (with delete button)
        if (isOnSavedPage) {
            card.innerHTML = createSavedCardHTML(hustle, allHustles);
        } else {
            card.innerHTML = createCardHTML(hustle, allHustles);
        }
        
        container.appendChild(card);
    });
}

// Function to create saved card HTML with delete button
function createSavedCardHTML(hustle, hustlesArray) {
    const hustleIndex = hustlesArray.indexOf(hustle);
    return `
        <div class="copy-button-container">
            <button class="copy-hustle-btn" data-hustle-index="${hustleIndex}">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
                Copy
            </button>
            <button class="delete-hustle-btn" data-hustle-index="${hustleIndex}">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="3 6 5 6 21 6"></polyline>
                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    <line x1="10" y1="11" x2="10" y2="17"></line>
                    <line x1="14" y1="11" x2="14" y2="17"></line>
                </svg>
                Delete
            </button>
        </div>
        <h3>${hustle.name.replace(/['"*\n]/g, " ").trim()}</h3>
        <div class="hustle-details">
            <p><strong>Executive Summary:</strong> ${hustle.summary}</p>
            
            <div class="hustle-metrics">
                <span class="metric"><strong>Difficulty:</strong> ${hustle.difficulty}</span>
                <span class="metric"><strong>Profitability:</strong> <span class="profit-badge">${hustle.profitability}</span></span>
                <span class="metric"><strong>Initial Cost:</strong> ${hustle.cost}</span>
            </div>
            
            <div class="metrics-section">
                <h4>Key Metrics</h4>
                <div class="metrics-grid">
                    <div class="metric-item">
                        <strong>Startup Time:</strong><br>${hustle.metrics.startupTime}
                    </div>
                    <div class="metric-item">
                        <strong>Break-even:</strong><br>${hustle.metrics.breakEven}
                    </div>
                    <div class="metric-item">
                        <strong>Scalability:</strong><br>${hustle.metrics.scalability}
                    </div>
                </div>
            </div>
            
            <div class="action-plan-section">
                <h4>Action Plan (First Month)</h4>
                <div class="timeline">
                    ${hustle.actionPlan.map(((plan, planIndex) => `
                        <div class="timeline-item">
                            <div class="timeline-marker">W${planIndex + 1}</div>
                            <div class="timeline-content">${plan}</div>
                        </div>
                    `)).join("")}
                </div>
            </div>
            
            <div class="resources-section">
                <h4>Resources</h4>
                <div class="resources-grid">
                    <div class="resource-item">
                        <strong>🛠️ Tools:</strong>
                        <ul>${hustle.resources.tools.map((tool => `<li>${tool}</li>`)).join("")}</ul>
                    </div>
                    <div class="resource-item">
                        <strong>💻 Platforms:</strong>
                        <ul>${hustle.resources.platforms.map((platform => `<li>${platform}</li>`)).join("")}</ul>
                    </div>
                    <div class="resource-item">
                        <strong>👥 Communities:</strong>
                        <ul>${hustle.resources.communities.map((community => `<li>${community}</li>`)).join("")}</ul>
                    </div>
                </div>
            </div>
            
            <div class="monetization-section">
                <h4>Monetization Streams</h4>
                <div class="monetization-list">
                    ${hustle.monetization.map(((stream, streamIndex) => `
                        <div class="monetization-item">
                            <span class="monetization-number">${streamIndex + 1}</span>
                            <span class="monetization-content">${stream}</span>
                        </div>
                    `)).join("")}
                </div>
            </div>
            
            <div class="risks-section">
                <h4>Risk Analysis</h4>
                ${hustle.risks.map((risk => `
                    <div class="risk-item">
                        <div class="risk-challenge">
                            <strong>⚠️ Challenge:</strong> ${risk.challenge}
                        </div>
                        <div class="risk-solution">
                            <strong>💡 Solution:</strong> ${risk.solution}
                        </div>
                    </div>
                `)).join("")}
            </div>
        </div>
    `;
}

// Function to simulate progress bar updates
function updateProgressBar() {
    const progressFill = document.querySelector('.progress-fill');
    if (!progressFill) return;
    
    // Reset the progress bar to 0%
    progressFill.style.width = '0%';
    
    // Set up timing for 20% increments every second
    let progress = 0;
    const interval = setInterval(() => {
        progress += 20;
        
        if (progress > 100) {
            progress = 100;
            clearInterval(interval);
        }
        
        progressFill.style.width = `${progress}%`;
        
        // Clear interval after reaching 100%
        if (progress >= 100) {
            clearInterval(interval);
            window.progressInterval = null;
        }
    }, 1000); // Update every 1 second (5 updates over 5 seconds)
    
    // Store the interval ID so it can be cleared if needed
    window.progressInterval = interval;
}

// Function to save city image to local storage
function saveCityImageToCache(city, imageData) {
    try {
        const cityImageCache = JSON.parse(localStorage.getItem('cityImageCache') || '{}');
        
        // Store the image data with a timestamp
        cityImageCache[city] = {
            imageData: imageData,
            timestamp: Date.now()
        };
        
        // Limit cache size to 10 cities (to prevent localStorage from getting too large)
        const cities = Object.keys(cityImageCache);
        if (cities.length > 10) {
            // Find the oldest entry and remove it
            let oldestCity = cities[0];
            let oldestTime = cityImageCache[oldestCity].timestamp;
            
            for (const cachedCity of cities) {
                if (cityImageCache[cachedCity].timestamp < oldestTime) {
                    oldestTime = cityImageCache[cachedCity].timestamp;
                    oldestCity = cachedCity;
                }
            }
            
            delete cityImageCache[oldestCity];
        }
        
        localStorage.setItem('cityImageCache', JSON.stringify(cityImageCache));
    } catch (error) {
        console.warn('Error saving city image to cache:', error);
        // If localStorage fails, we just continue without caching
    }
}

// Function to get city image from cache
function getCityImageFromCache(city) {
    try {
        const cityImageCache = JSON.parse(localStorage.getItem('cityImageCache') || '{}');
        const cachedImage = cityImageCache[city];
        
        // Check if we have a cached image and it's less than 24 hours old
        if (cachedImage && Date.now() - cachedImage.timestamp < 24 * 60 * 60 * 1000) {
            return cachedImage.imageData;
        }
        
        return null;
    } catch (error) {
        console.warn('Error retrieving city image from cache:', error);
        return null;
    }
}

// Add a function to animate the city image reveal
function animateCityImageReveal() {
    const cityImageContainer = document.getElementById("city-image-container");
    cityImageContainer.classList.add("visible");
    
    // If the container has an image, add a slight zoom effect
    const cityImage = cityImageContainer.querySelector("img");
    if (cityImage) {
        cityImage.style.transform = "scale(1.02)";
        setTimeout(() => {
            cityImage.style.transform = "scale(1)";
        }, 200);
    }
}

// Update the generateCityImage function to use animation
async function generateCityImage(city) {
    const cityImageContainer = document.getElementById("city-image-container");
    
    // Show loading state
    cityImageContainer.innerHTML = `
        <div class="loading-overlay">
            <div class="loader-circle"></div>
            <p>Generating image of ${city}...</p>
        </div>
    `;
    
    try {
        // Check cache first
        const cachedImageData = getCityImageFromCache(city);
        if (cachedImageData) {
            console.log(`Using cached image for ${city}`);
            
            // Display the cached image
            cityImageContainer.innerHTML = `
                <img src="data:image/jpeg;base64,${cachedImageData}" 
                     alt="Generated cityscape of ${city}" 
                     loading="lazy">
                <div class="image-caption">Explore opportunities in ${city}</div>
            `;
            
            // Animate the reveal
            setTimeout(animateCityImageReveal, 100);
            return true;
        }
        
        // If no cached image, generate a new one
        const prompt = `Generate a beautiful, realistic cityscape photo of ${city} that shows iconic landmarks and the city's atmosphere. Make it look like a professional travel photograph with good lighting and composition. 700x300 pixels.`;
        
        const response = await fetch(`${GEMINI_CONFIG.IMAGE_API_URL}?key=${GEMINI_CONFIG.IMAGE_API_KEY}`, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }],
                generationConfig: {
                    temperature: 0.7,
                    topK: 32,
                    topP: 1,
                    maxOutputTokens: 2048,
                },
            }),
        });
        
        if (!response.ok) {
            throw new Error(`Image generation failed: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Check if we have an image in the response
        if (data.candidates && 
            data.candidates[0] && 
            data.candidates[0].content && 
            data.candidates[0].content.parts && 
            data.candidates[0].content.parts.some(part => part.inlineData)) {
            
            // Find the image part
            const imagePart = data.candidates[0].content.parts.find(part => part.inlineData);
            
            if (imagePart) {
                const imageBase64 = imagePart.inlineData.data;
                
                // Cache the generated image
                saveCityImageToCache(city, imageBase64);
                
                // Display the image
                cityImageContainer.innerHTML = `
                    <img src="data:image/jpeg;base64,${imageBase64}" 
                         alt="Generated cityscape of ${city}" 
                         loading="lazy">
                    <div class="image-caption">Explore opportunities in ${city}</div>
                `;
                
                // Animate the reveal
                setTimeout(animateCityImageReveal, 100);
                return true;
            }
        }
        
        // If we can't get an image, show a fallback
        throw new Error("Image generation returned no usable image data");
        
    } catch (error) {
        console.error("Error generating city image:", error);
        
        // Show error state with placeholder and retry button
        showImageError(city, error.message || "Unknown error");
        return false;
    }
}

// Function to show an error when image generation fails
function showImageError(city, errorMessage) {
    const cityImageContainer = document.getElementById("city-image-container");
    cityImageContainer.innerHTML = `
        <div style="width:100%;height:100%;background:linear-gradient(135deg, #34C759 0%, #007AFF 100%);display:flex;flex-direction:column;align-items:center;justify-content:center;">
            <div style="color:white;font-size:1.5rem;font-weight:bold;text-align:center;padding:20px;">
                ${city}
                <div style="font-size:1rem;margin-top:10px;">Discover hustle opportunities</div>
            </div>
            <button onclick="retryImageGeneration('${city}')" class="retry-button" aria-label="Retry image generation">
                Retry Image
            </button>
        </div>
    `;
}

// Function to retry image generation
async function retryImageGeneration(city) {
    try {
        const result = await generateCityImage(city);
        if (!result) {
            showImageError(city, "Failed to generate image on retry");
        }
    } catch (error) {
        console.error("Error retrying image generation:", error);
        showImageError(city, error.message || "Unknown error during retry");
    }
}